FILES = {}

FILES["pyproject.toml"] = [
    "[build-system]\n",
    "requires = [\"setuptools>=61.0\", \"wheel\"]\n",
    "build-backend = \"setuptools.build_meta\"\n",
    "\n",
    "[project]\n",
    "name = \"erisml\"\n",
    "version = \"0.1.0\"\n",
    "description = \"ErisML: a modeling library for governed foundation-model agents in pervasive environments\"\n",
    "readme = \"README.md\"\n",
    "requires-python = \">=3.10\"\n",
    "authors = [ {name = \"Your Name\", email = \"you@example.com\"} ]\n",
    "license = {text = \"MIT\"}\n",
    "dependencies = [\n",
    "  \"lark>=1.1.7\",\n",
    "  \"pydantic>=2.0.0\",\n",
    "  \"pettingzoo>=1.24.0\",\n",
    "  \"gymnasium>=0.28.0\",\n",
    "  \"tarski>=0.7.1\",\n",
    "  \"prometheus-client>=0.16.0\",\n",
    "  \"structlog>=24.0.0\",\n",
    "]\n",
    "\n",
    "[project.optional-dependencies]\n",
    "dev = [\n",
    "  \"pytest>=7.0.0\",\n",
    "  \"mypy>=1.0.0\",\n",
    "  \"black==24.4.2\",\n",
    "  \"isort>=5.0.0\",\n",
    "  \"ruff>=0.4.8\",\n",
    "  \"taplo>=0.9.0\",\n",
    "]\n",
    "\n",
    "[tool.setuptools]\n",
    "package-dir = {\"\" = \"src\"}\n",
    "\n",
    "[tool.setuptools.packages.find]\n",
    "where = [\"src\"]\n",
    "\n",
    "[tool.black]\n",
    "line-length = 88\n",
    "target-version = [\"py310\"]\n",
    "required-version = \"24.4.2\"\n",
    "\n",
    "[tool.isort]\n",
    "profile = \"black\"\n",
    "\n",
    "[tool.ruff]\n",
    "line-length = 88\n",
]

FILES[".gitignore"] = [
    "__pycache__/\n",
    "*.py[cod]\n",
    "*.pyo\n",
    ".env\n",
    ".venv/\n",
    "venv/\n",
    "env/\n",
    "build/\n",
    "dist/\n",
    "*.egg-info/\n",
    ".mypy_cache/\n",
    ".pytest_cache/\n",
    ".coverage\n",
    "htmlcov/\n",
    ".DS_Store\n",
    ".idea/\n",
    ".vscode/\n",
]

FILES["README.md"] = [
    "# ErisML Library\n",
    "\n",
    "ErisML is a modeling layer for governed, foundation-model-enabled agents\n",
    "operating in pervasive environments.\n",
    "\n",
    "This repository contains a production-style Python library with:\n",
    "- Language grammar (Lark)\n",
    "- Typed AST (Pydantic)\n",
    "- Core IR and norm engine\n",
    "- PettingZoo adapter\n",
    "- Planning adapter stub\n",
    "- TinyHome example\n",
    "- GitHub Actions CI (Black, Ruff, Taplo)\n",
    "\n",
    "## Quickstart\n",
    "\n",
    "```bash\n",
    "python -m venv .venv\n",
    "source .venv/bin/activate   # Windows: .\\\\.venv\\\\Scripts\\\\activate\n",
    "pip install -e \".[dev]\"\n",
    "pytest\n",
    "```\n",
]

FILES[".github/workflows/ci.yaml"] = [
    "name: ErisML CI\n",
    "\n",
    "on:\n",
    "  push:\n",
    "    branches: [ main ]\n",
    "  pull_request:\n",
    "    branches: [ main ]\n",
    "\n",
    "jobs:\n",
    "  build:\n",
    "    runs-on: ubuntu-latest\n",
    "    steps:\n",
    "\n",
    "      - uses: actions/checkout@v4\n",
    "        with:\n",
    "          clean: true\n",
    "          fetch-depth: 0\n",
    "\n",
    "      - uses: actions/setup-python@v5\n",
    "        with:\n",
    "          python-version: '3.12'\n",
    "\n",
    "      - run: |\n",
    "          python -m pip install --upgrade pip\n",
    "          pip install -e \".[dev]\"\n",
    "\n",
    "      - run: pip install black==24.4.2 ruff taplo\n",
    "\n",
    "      - run: |\n",
    "          black --check src tests\n",
    "          ruff check src tests\n",
    "          taplo lint pyproject.toml\n",
    "\n",
    "      - run: pytest -q --disable-warnings --maxfail=1\n",
    "\n",
    "      - run: |\n",
    "          if [ -n \"$(git status --porcelain)\" ]; then\n",
    "            echo 'ERROR: repo not clean!'\n",
    "            exit 1\n",
    "          fi\n",
]
# ============================
# CHUNK 2b — LANGUAGE LAYER
# ============================

FILES["src/erisml/language/grammar.lark"] = [
    "?start: model\n",
    "\n",
    "model: environment_block agent_block+ norms_block? dynamics_block?\n",
    "\n",
    "environment_block: \"environment\" CNAME \"{\" env_body \"}\"\n",
    "env_body: objects_decl state_decl env_dynamics_decl?\n",
    "\n",
    "objects_decl: \"objects:\" CNAME (\",\" CNAME)* \";\"\n",
    "state_decl: \"state:\" state_var_decl*\n",
    "state_var_decl: CNAME \":\" type_expr \";\"\n",
    "\n",
    "type_expr: base_type\n",
    "         | CNAME \"->\" base_type\n",
    "base_type: \"bool\" | \"int\" | \"real\" | \"(\" type_expr \",\" type_expr \")\"\n",
    "\n",
    "agent_block: \"agent\" CNAME \"{\" agent_body \"}\"\n",
    "agent_body: capabilities_decl beliefs_decl? intents_decl? constraints_decl?\n",
    "\n",
    "capabilities_decl: \"capabilities:\" CNAME* \";\"\n",
    "beliefs_decl: \"beliefs:\" CNAME* \";\"\n",
    "intents_decl: \"intents:\" CNAME* \";\"\n",
    "constraints_decl: \"constraints:\" CNAME* \";\"\n",
    "\n",
    "norms_block: \"norms\" CNAME \"{\" norm_rule* \"}\"\n",
    "norm_rule: prohibition_rule\n",
    "         | obligation_rule\n",
    "         | sanction_rule\n",
    "\n",
    "prohibition_rule: \"prohibition:\" expr \";\"\n",
    "obligation_rule:  \"obligation:\" expr \";\"\n",
    "sanction_rule:    \"sanction:\" expr \";\"\n",
    "\n",
    "dynamics_block: \"dynamics\" \"{\" joint_action_decl reward_decl \"}\"\n",
    "joint_action_decl: \"joint_action\" \"{\" joint_term+ \"}\"\n",
    "joint_term: CNAME \".\" CNAME \"->\" \"cost\" NUMBER \";\"\n",
    "reward_decl: \"reward\" \"{\" reward_term+ \"}\"\n",
    "reward_term: CNAME \":\" expr \";\"\n",
    "\n",
    "?expr: CNAME\n",
    "     | expr \"==\" expr\n",
    "     | expr \"&&\" expr\n",
    "     | expr \"||\" expr\n",
    "     | \"(\" expr \")\"\n",
    "\n",
    "%import common.CNAME\n",
    "%import common.NUMBER\n",
    "%import common.WS\n",
    "%ignore WS\n",
]

FILES["src/erisml/language/ast.py"] = [
    "from __future__ import annotations\n",
    "\n",
    "from typing import List, Optional, Literal\n",
    "from pydantic import BaseModel\n",
    "\n",
    "\n",
    "class TypeExpr(BaseModel):\n",
    "    kind: Literal[\"base\", \"mapping\"]\n",
    "    base: str\n",
    "    key_object_type: Optional[str] = None\n",
    "\n",
    "\n",
    "class StateVarDecl(BaseModel):\n",
    "    name: str\n",
    "    type: TypeExpr\n",
    "\n",
    "\n",
    "class EnvDecl(BaseModel):\n",
    "    name: str\n",
    "    object_types: List[str]\n",
    "    state_vars: List[StateVarDecl]\n",
    "\n",
    "\n",
    "class AgentDecl(BaseModel):\n",
    "    name: str\n",
    "    capabilities: List[str]\n",
    "    beliefs: List[str] = []\n",
    "    intents: List[str] = []\n",
    "    constraints: List[str] = []\n",
    "\n",
    "\n",
    "class NormRuleDecl(BaseModel):\n",
    "    kind: Literal[\"prohibition\", \"obligation\", \"sanction\"]\n",
    "    expr: str\n",
    "\n",
    "\n",
    "class NormsDecl(BaseModel):\n",
    "    name: str\n",
    "    rules: List[NormRuleDecl]\n",
    "\n",
    "\n",
    "class ModelAST(BaseModel):\n",
    "    environment: EnvDecl\n",
    "    agents: List[AgentDecl]\n",
    "    norms: Optional[NormsDecl] = None\n",
]

FILES["src/erisml/language/parser.py"] = [
    "from __future__ import annotations\n",
    "\n",
    "from pathlib import Path\n",
    "from typing import Any, Dict, List\n",
    "\n",
    "from lark import Lark, Transformer, Token\n",
    "\n",
    "from .ast import (\n",
    "    AgentDecl,\n",
    "    EnvDecl,\n",
    "    ModelAST,\n",
    "    NormRuleDecl,\n",
    "    NormsDecl,\n",
    "    StateVarDecl,\n",
    "    TypeExpr,\n",
    ")\n",
    "\n",
    "\n",
    "def _grammar_text() -> str:\n",
    "    grammar_path = Path(__file__).with_name(\"grammar.lark\")\n",
    "    return grammar_path.read_text(encoding=\"utf-8\")\n",
    "\n",
    "\n",
    "_PARSER = Lark(_grammar_text(), start=\"model\", parser=\"lalr\")\n",
    "\n",
    "\n",
    "class ASTBuilder(Transformer):\n",
    "    def environment_block(self, items: List[Any]) -> EnvDecl:\n",
    "        name_token: Token = items[0]\n",
    "        env_body: Dict[str, Any] = items[1]\n",
    "        return EnvDecl(\n",
    "            name=name_token.value,\n",
    "            object_types=env_body.get(\"object_types\", []),\n",
    "            state_vars=env_body.get(\"state_vars\", []),\n",
    "        )\n",
    "\n",
    "    def env_body(self, items: List[Any]) -> Dict[str, Any]:\n",
    "        out: Dict[str, Any] = {\"object_types\": [], \"state_vars\": []}\n",
    "        for item in items:\n",
    "            if isinstance(item, dict) and \"object_types\" in item:\n",
    "                out[\"object_types\"] = item[\"object_types\"]\n",
    "            elif isinstance(item, list):\n",
    "                out[\"state_vars\"] = item\n",
    "        return out\n",
    "\n",
    "    def objects_decl(self, items: List[Token]) -> Dict[str, Any]:\n",
    "        return {\"object_types\": [tok.value for tok in items]}\n",
    "\n",
    "    def state_decl(self, items: List[StateVarDecl]) -> List[StateVarDecl]:\n",
    "        return items\n",
    "\n",
    "    def state_var_decl(self, items: List[Any]) -> StateVarDecl:\n",
    "        name_token: Token = items[0]\n",
    "        texpr: TypeExpr = items[1]\n",
    "        return StateVarDecl(name=name_token.value, type=texpr)\n",
    "\n",
    "    def type_expr(self, items: List[Any]) -> TypeExpr:\n",
    "        if len(items) == 1:\n",
    "            base = items[0].value\n",
    "            return TypeExpr(kind=\"base\", base=base)\n",
    "        if len(items) == 2:\n",
    "            key_type: Token = items[0]\n",
    "            base_type: Token = items[1]\n",
    "            return TypeExpr(\n",
    "                kind=\"mapping\",\n",
    "                base=base_type.value,\n",
    "                key_object_type=key_type.value,\n",
    "            )\n",
    "        raise ValueError(\"Invalid type_expr items\")\n",
    "\n",
    "    def agent_block(self, items: List[Any]) -> AgentDecl:\n",
    "        name_token: Token = items[0]\n",
    "        body: Dict[str, Any] = items[1]\n",
    "        return AgentDecl(\n",
    "            name=name_token.value,\n",
    "            capabilities=body.get(\"capabilities\", []),\n",
    "            beliefs=body.get(\"beliefs\", []),\n",
    "            intents=body.get(\"intents\", []),\n",
    "            constraints=body.get(\"constraints\", []),\n",
    "        )\n",
    "\n",
    "    def agent_body(self, items: List[Any]) -> Dict[str, Any]:\n",
    "        d: Dict[str, Any] = {\n",
    "            \"capabilities\": [],\n",
    "            \"beliefs\": [],\n",
    "            \"intents\": [],\n",
    "            \"constraints\": [],\n",
    "        }\n",
    "        for item in items:\n",
    "            if isinstance(item, dict):\n",
    "                d.update(item)\n",
    "        return d\n",
    "\n",
    "    def capabilities_decl(self, items: List[Token]) -> Dict[str, Any]:\n",
    "        return {\"capabilities\": [tok.value for tok in items]}\n",
    "\n",
    "    def beliefs_decl(self, items: List[Token]) -> Dict[str, Any]:\n",
    "        return {\"beliefs\": [tok.value for tok in items]}\n",
    "\n",
    "    def intents_decl(self, items: List[Token]) -> Dict[str, Any]:\n",
    "        return {\"intents\": [tok.value for tok in items]}\n",
    "\n",
    "    def constraints_decl(self, items: List[Token]) -> Dict[str, Any]:\n",
    "        return {\"constraints\": [tok.value for tok in items]}\n",
    "\n",
    "    def norms_block(self, items: List[Any]) -> NormsDecl:\n",
    "        name_token: Token = items[0]\n",
    "        rules: List[NormRuleDecl] = items[1:]\n",
    "        return NormsDecl(name=name_token.value, rules=rules)\n",
    "\n",
    "    def prohibition_rule(self, items: List[Any]) -> NormRuleDecl:\n",
    "        expr_str = self._expr_to_str(items[0])\n",
    "        return NormRuleDecl(kind=\"prohibition\", expr=expr_str)\n",
    "\n",
    "    def obligation_rule(self, items: List[Any]) -> NormRuleDecl:\n",
    "        expr_str = self._expr_to_str(items[0])\n",
    "        return NormRuleDecl(kind=\"obligation\", expr=expr_str)\n",
    "\n",
    "    def sanction_rule(self, items: List[Any]) -> NormRuleDecl:\n",
    "        expr_str = self._expr_to_str(items[0])\n",
    "        return NormRuleDecl(kind=\"sanction\", expr=expr_str)\n",
    "\n",
    "    def expr(self, items: List[Any]) -> Any:\n",
    "        if len(items) == 1:\n",
    "            return items[0]\n",
    "        if len(items) == 3:\n",
    "            return (items[1].value, items[0], items[2])\n",
    "        return items[0]\n",
    "\n",
    "    def CNAME(self, token: Token) -> Token:\n",
    "        return token\n",
    "\n",
    "    def _expr_to_str(self, node: Any) -> str:\n",
    "        if isinstance(node, Token):\n",
    "            return node.value\n",
    "        if isinstance(node, tuple) and len(node) == 3:\n",
    "            op, left, right = node\n",
    "            return f\"({self._expr_to_str(left)} {op} {self._expr_to_str(right)})\"\n",
    "        return str(node)\n",
    "\n",
    "    def model(self, items: List[Any]) -> ModelAST:\n",
    "        env: EnvDecl | None = None\n",
    "        agents: List[AgentDecl] = []\n",
    "        norms: NormsDecl | None = None\n",
    "        for item in items:\n",
    "            if isinstance(item, EnvDecl):\n",
    "                env = item\n",
    "            elif isinstance(item, AgentDecl):\n",
    "                agents.append(item)\n",
    "            elif isinstance(item, NormsDecl):\n",
    "                norms = item\n",
    "        assert env is not None, \"Model must have an environment\"\n",
    "        return ModelAST(environment=env, agents=agents, norms=norms)\n",
    "\n",
    "\n",
    "def parse_erisml(source: str) -> ModelAST:\n",
    "    # Parse ErisML source code into a typed AST.\n",
    "    tree = _PARSER.parse(source)\n",
    "    ast = ASTBuilder().transform(tree)\n",
    "    assert isinstance(ast, ModelAST)\n",
    "    return ast\n",
]
# ============================
# CHUNK 2c — CORE, INTEROP, METRICS
# ============================

FILES["src/erisml/core/types.py"] = [
    "from __future__ import annotations\n",
    "\n",
    "from dataclasses import dataclass\n",
    "from enum import Enum\n",
    "from typing import Any, Callable, Dict, List, Optional\n",
    "\n",
    "\n",
    "class BaseType(Enum):\n",
    "    BOOL = \"bool\"\n",
    "    INT = \"int\"\n",
    "    REAL = \"real\"\n",
    "    STR = \"str\"\n",
    "\n",
    "\n",
    "@dataclass\n",
    "class ObjectType:\n",
    "    name: str\n",
    "    instances: List[str]\n",
    "\n",
    "\n",
    "@dataclass\n",
    "class StateVarDomain:\n",
    "    base_type: BaseType\n",
    "    key_object_type: Optional[str] = None\n",
    "\n",
    "    @property\n",
    "    def is_mapping(self) -> bool:\n",
    "        return self.key_object_type is not None\n",
    "\n",
    "\n",
    "@dataclass\n",
    "class StateVar:\n",
    "    name: str\n",
    "    domain: StateVarDomain\n",
    "\n",
    "\n",
    "@dataclass\n",
    "class EnvironmentRule:\n",
    "    name: str\n",
    "    param_names: List[str]\n",
    "    update_fn: Callable[[Dict[str, Any], Dict[str, Any]], Dict[str, Any]]\n",
    "\n",
    "\n",
    "@dataclass\n",
    "class ActionSchema:\n",
    "    name: str\n",
    "    param_names: List[str]\n",
    "\n",
    "\n",
    "@dataclass\n",
    "class ActionInstance:\n",
    "    agent: str\n",
    "    name: str\n",
    "    params: Dict[str, Any]\n",
    "\n",
    "    def __repr__(self) -> str:\n",
    "        param_str = \", \".join(f\"{k}={v!r}\" for k, v in self.params.items())\n",
    "        return f\"{self.agent}.{self.name}({param_str})\"\n",
]

FILES["src/erisml/core/model.py"] = [
    "from __future__ import annotations\n",
    "\n",
    "from dataclasses import dataclass, field\n",
    "from typing import Dict, List, Optional\n",
    "\n",
    "from .types import ActionSchema, EnvironmentRule, ObjectType, StateVar, StateVarDomain\n",
    "\n",
    "\n",
    "@dataclass\n",
    "class EnvironmentModel:\n",
    "    name: str\n",
    "    object_types: Dict[str, ObjectType] = field(default_factory=dict)\n",
    "    state_vars: Dict[str, StateVar] = field(default_factory=dict)\n",
    "    rules: Dict[str, EnvironmentRule] = field(default_factory=dict)\n",
    "\n",
    "    def add_object_type(self, name: str, instances: List[str]) -> None:\n",
    "        self.object_types[name] = ObjectType(name, instances)\n",
    "\n",
    "    def add_state_var(self, name: str, domain: StateVarDomain) -> None:\n",
    "        self.state_vars[name] = StateVar(name, domain)\n",
    "\n",
    "    def add_rule(self, rule: EnvironmentRule) -> None:\n",
    "        self.rules[rule.name] = rule\n",
    "\n",
    "\n",
    "@dataclass\n",
    "class AgentModel:\n",
    "    name: str\n",
    "    capabilities: Dict[str, ActionSchema] = field(default_factory=dict)\n",
    "\n",
    "    def add_capability(self, schema: ActionSchema) -> None:\n",
    "        self.capabilities[schema.name] = schema\n",
    "\n",
    "\n",
    "@dataclass\n",
    "class ErisModel:\n",
    "    env: EnvironmentModel\n",
    "    agents: Dict[str, AgentModel]\n",
    "    norms: Optional[\"NormSystem\"] = None  # NormSystem defined in norms.py\n",
    "\n",
    "    def agent(self, name: str) -> AgentModel:\n",
    "        return self.agents[name]\n",
]

FILES["src/erisml/core/norms.py"] = [
    "from __future__ import annotations\n",
    "\n",
    "from dataclasses import dataclass, field\n",
    "from typing import Callable, Dict, List, Optional\n",
    "\n",
    "from .types import ActionInstance\n",
    "\n",
    "\n",
    "class NormViolation(Exception):\n",
    "    def __init__(self, message: str, violated: Optional[List[\"NormRule\"]] = None):\n",
    "        super().__init__(message)\n",
    "        self.violated = violated or []\n",
    "\n",
    "\n",
    "@dataclass\n",
    "class NormRule:\n",
    "    name: str\n",
    "    kind: str  # e.g. \"prohibition\", \"obligation\", \"sanction\"\n",
    "    predicate: Callable[[Dict[str, object], ActionInstance], bool]\n",
    "\n",
    "\n",
    "@dataclass\n",
    "class NormSystem:\n",
    "    name: str\n",
    "    rules: List[NormRule] = field(default_factory=list)\n",
    "\n",
    "    def add_rule(self, rule: NormRule) -> None:\n",
    "        self.rules.append(rule)\n",
    "\n",
    "    def check_prohibitions(self, state: Dict[str, object], action: ActionInstance) -> List[NormRule]:\n",
    "        violated: List[NormRule] = []\n",
    "        for rule in self.rules:\n",
    "            if rule.kind == \"prohibition\" and rule.predicate(state, action):\n",
    "                violated.append(rule)\n",
    "        return violated\n",
    "\n",
    "    def obligations_active(self, state: Dict[str, object], action: ActionInstance) -> List[NormRule]:\n",
    "        active: List[NormRule] = []\n",
    "        for rule in self.rules:\n",
    "            if rule.kind == \"obligation\" and rule.predicate(state, action):\n",
    "                active.append(rule)\n",
    "        return active\n",
    "\n",
    "    def sanctions_triggered(self, state: Dict[str, object], action: ActionInstance) -> List[NormRule]:\n",
    "        triggered: List[NormRule] = []\n",
    "        for rule in self.rules:\n",
    "            if rule.kind == \"sanction\" and rule.predicate(state, action):\n",
    "                triggered.append(rule)\n",
    "        return triggered\n",
]

FILES["src/erisml/core/engine.py"] = [
    "from __future__ import annotations\n",
    "\n",
    "from dataclasses import dataclass, field\n",
    "from typing import Any, Dict\n",
    "\n",
    "from .model import ErisModel\n",
    "from .norms import NormSystem, NormViolation\n",
    "from .types import ActionInstance\n",
    "\n",
    "\n",
    "@dataclass\n",
    "class NormMetrics:\n",
    "    steps: int = 0\n",
    "    violation_count: int = 0\n",
    "\n",
    "    @property\n",
    "    def nvr(self) -> float:\n",
    "        if self.steps == 0:\n",
    "            return 0.0\n",
    "        return self.violation_count / self.steps\n",
    "\n",
    "\n",
    "@dataclass\n",
    "class ErisEngine:\n",
    "    model: ErisModel\n",
    "    metrics: NormMetrics = field(default_factory=NormMetrics)\n",
    "\n",
    "    def step(self, state: Dict[str, Any], action: ActionInstance) -> Dict[str, Any]:\n",
    "        self.metrics.steps += 1\n",
    "\n",
    "        norms: NormSystem | None = self.model.norms\n",
    "        if norms is not None:\n",
    "            violated = norms.check_prohibitions(state, action)\n",
    "            if violated:\n",
    "                self.metrics.violation_count += 1\n",
    "                raise NormViolation(\n",
    "                    f\"Action {action} violates norms: \" + \", \".join(r.name for r in violated),\n",
    "                    violated=violated,\n",
    "                )\n",
    "\n",
    "        env = self.model.env\n",
    "        if action.name not in env.rules:\n",
    "            raise KeyError(f\"No environment rule for action '{action.name}'\")\n",
    "\n",
    "        rule = env.rules[action.name]\n",
    "        new_state = rule.update_fn(state, action.params)\n",
    "        return new_state\n",
]

FILES["src/erisml/interop/pettingzoo_adapter.py"] = [
    "from __future__ import annotations\n",
    "\n",
    "from typing import Any, Dict\n",
    "\n",
    "from gymnasium import spaces\n",
    "from pettingzoo.utils import AECEnv\n",
    "\n",
    "from erisml.core.engine import ErisEngine\n",
    "from erisml.core.model import ErisModel\n",
    "from erisml.core.types import ActionInstance\n",
    "\n",
    "\n",
    "class ErisPettingZooEnv(AECEnv):\n",
    "    \"\"\"Minimal PettingZoo adapter. Customize for real domains.\"\"\"\n",
    "\n",
    "    metadata = {\"render_modes\": [\"human\"]}\n",
    "\n",
    "    def __init__(self, model: ErisModel):\n",
    "        super().__init__()\n",
    "        self.model = model\n",
    "        self.engine = ErisEngine(model)\n",
    "        self.possible_agents = list(model.agents.keys())\n",
    "        self.agents = self.possible_agents[:]\n",
    "        self._agent_index = 0\n",
    "        self._state: Dict[str, Any] = {}\n",
    "        self._cumulative_rewards = {a: 0.0 for a in self.agents}\n",
    "\n",
    "        self.action_spaces = {a: spaces.Discrete(4) for a in self.agents}\n",
    "        self.observation_spaces = {a: spaces.Dict({}) for a in self.agents}\n",
    "\n",
    "    def reset(self, seed=None, options=None):\n",
    "        self.agents = self.possible_agents[:]\n",
    "        self._agent_index = 0\n",
    "        self._state = {}\n",
    "        self._cumulative_rewards = {a: 0.0 for a in self.agents}\n",
    "\n",
    "    def observe(self, agent):\n",
    "        return {}\n",
    "\n",
    "    def step(self, action):\n",
    "        if not self.agents:\n",
    "            return\n",
    "        agent = self.agents[self._agent_index]\n",
    "        act = self._decode_action(agent, action)\n",
    "        try:\n",
    "            self._state = self.engine.step(self._state, act)\n",
    "        except Exception as exc:\n",
    "            print(f\"Engine error: {exc}\")\n",
    "        self._agent_index = (self._agent_index + 1) % len(self.agents)\n",
    "\n",
    "    def _decode_action(self, agent: str, action: int) -> ActionInstance:\n",
    "        return ActionInstance(agent=agent, name=\"noop\", params={})\n",
    "\n",
    "    def render(self):\n",
    "        print(\"State:\", self._state)\n",
    "\n",
    "    def close(self):\n",
    "        pass\n",
]

FILES["src/erisml/interop/pddl_adapter.py"] = [
    "from __future__ import annotations\n",
    "\n",
    "from erisml.core.model import ErisModel\n",
    "\n",
    "try:\n",
    "    import tarski\n",
    "    from tarski import fstrips as fs\n",
    "except ImportError:  # pragma: no cover\n",
    "    tarski = None\n",
    "    fs = None\n",
    "\n",
    "\n",
    "def erisml_to_tarski(model: ErisModel):\n",
    "    \"\"\"Convert ErisML model to Tarski FSTRIPS problem (stub).\"\"\"\n",
    "    if tarski is None or fs is None:\n",
    "        raise ImportError(\"tarski not installed. Install via `pip install tarski`.\")\n",
    "\n",
    "    lang = fs.language.FStripsLanguage(\"erisml\")\n",
    "\n",
    "    obj_sorts = {}\n",
    "    for name, obj_type in model.env.object_types.items():\n",
    "        sort = lang.sort(name)\n",
    "        obj_sorts[name] = sort\n",
    "        for inst in obj_type.instances:\n",
    "            lang.constant(inst, sort)\n",
    "\n",
    "    problem = fs.Problem(lang)\n",
    "    return problem\n",
]

FILES["src/erisml/metrics/telemetry.py"] = [
    "from __future__ import annotations\n",
    "\n",
    "import logging\n",
    "from prometheus_client import Counter\n",
    "\n",
    "\n",
    "logger = logging.getLogger(\"erisml\")\n",
    "\n",
    "NORM_VIOLATIONS = Counter(\n",
    "    \"erisml_norm_violations_total\",\n",
    "    \"Total norm violations observed\",\n",
    ")\n",
    "\n",
    "STEPS = Counter(\n",
    "    \"erisml_steps_total\",\n",
    "    \"Total engine steps\",\n",
    ")\n",
    "\n",
    "\n",
    "def log_step(violated: bool) -> None:\n",
    "    STEPS.inc()\n",
    "    if violated:\n",
    "        NORM_VIOLATIONS.inc()\n",
    "    logger.info(\"step\", extra={\"violated\": violated})\n",
]
FILES["src/erisml/examples/tiny_home.py"] = [
    "from __future__ import annotations\n",
    "\n",
    "from typing import Any, Dict\n",
    "\n",
    "from erisml.core.engine import ErisEngine\n",
    "from erisml.core.model import AgentModel, EnvironmentModel, ErisModel\n",
    "from erisml.core.norms import NormRule, NormSystem, NormViolation\n",
    "from erisml.core.types import (\n",
    "    ActionInstance,\n",
    "    ActionSchema,\n",
    "    BaseType,\n",
    "    EnvironmentRule,\n",
    "    StateVarDomain,\n",
    ")\n",
    "\n",
    "\n",
    "def build_tiny_home_model() -> ErisModel:\n",
    "    env = EnvironmentModel(name=\"TinyHome\")\n",
    "    env.add_object_type(\"Room\", [\"r1\", \"r2\"])\n",
    "\n",
    "    env.add_state_var(\"location_human\", StateVarDomain(BaseType.STR))\n",
    "    env.add_state_var(\"location_robot\", StateVarDomain(BaseType.STR))\n",
    "    env.add_state_var(\"light_on_r1\", StateVarDomain(BaseType.BOOL))\n",
    "    env.add_state_var(\"light_on_r2\", StateVarDomain(BaseType.BOOL))\n",
    "\n",
    "    def move_robot_rule(state: Dict[str, Any], params: Dict[str, Any]) -> Dict[str, Any]:\n",
    "        from_room = params[\"from\"]\n",
    "        to_room = params[\"to\"]\n",
    "        new_state = dict(state)\n",
    "        if state[\"location_robot\"] == from_room:\n",
    "            new_state[\"location_robot\"] = to_room\n",
    "        return new_state\n",
    "\n",
    "    def toggle_light_rule(state: Dict[str, Any], params: Dict[str, Any]) -> Dict[str, Any]:\n",
    "        room = params[\"room\"]\n",
    "        new_state = dict(state)\n",
    "        key = f\"light_on_{room}\"\n",
    "        new_state[key] = not state[key]\n",
    "        return new_state\n",
    "\n",
    "    env.add_rule(EnvironmentRule(\"move_robot\", [\"from\", \"to\"], move_robot_rule))\n",
    "    env.add_rule(EnvironmentRule(\"toggle_light\", [\"room\"], toggle_light_rule))\n",
    "\n",
    "    robot = AgentModel(name=\"Robot\")\n",
    "    robot.add_capability(ActionSchema(\"move_robot\", [\"from\", \"to\"]))\n",
    "    robot.add_capability(ActionSchema(\"toggle_light\", [\"room\"]))\n",
    "\n",
    "    agents = {\"Robot\": robot}\n",
    "\n",
    "    norms = NormSystem(name=\"Safety\")\n",
    "\n",
    "    def prohibition_move_to_r2(state: Dict[str, Any], action: ActionInstance) -> bool:\n",
    "        return (\n",
    "            action.agent == \"Robot\"\n",
    "            and action.name == \"move_robot\"\n",
    "            and action.params.get(\"to\") == \"r2\"\n",
    "        )\n",
    "\n",
    "    norms.add_rule(NormRule(\"no_move_into_r2\", \"prohibition\", prohibition_move_to_r2))\n",
    "\n",
    "    def obligation_light_on_human_room(state: Dict[str, Any], action: ActionInstance) -> bool:\n",
    "        room = state[\"location_human\"]\n",
    "        key = f\"light_on_{room}\"\n",
    "        return not state[key]\n",
    "\n",
    "    norms.add_rule(NormRule(\"keep_human_room_lit\", \"obligation\", obligation_light_on_human_room))\n",
    "\n",
    "    model = ErisModel(env=env, agents=agents, norms=norms)\n",
    "    return model\n",
    "\n",
    "\n",
    "def demo_tiny_home_run() -> None:\n",
    "    model = build_tiny_home_model()\n",
    "    engine = ErisEngine(model)\n",
    "\n",
    "    state: Dict[str, Any] = {\n",
    "        \"location_human\": \"r1\",\n",
    "        \"location_robot\": \"r1\",\n",
    "        \"light_on_r1\": False,\n",
    "        \"light_on_r2\": False,\n",
    "    }\n",
    "\n",
    "    print(\"Initial state:\", state)\n",
    "\n",
    "    a1 = ActionInstance(agent=\"Robot\", name=\"toggle_light\", params={\"room\": \"r1\"})\n",
    "    state = engine.step(state, a1)\n",
    "    print(\"After toggle_light(r1):\", state)\n",
    "\n",
    "    a2 = ActionInstance(agent=\"Robot\", name=\"move_robot\", params={\"from\": \"r1\", \"to\": \"r2\"})\n",
    "    try:\n",
    "        state = engine.step(state, a2)\n",
    "    except NormViolation as exc:\n",
    "        print(\"Blocked action:\", a2)\n",
    "        print(\"Reason:\", exc)\n",
    "\n",
    "    print(\"Final state:\", state)\n",
    "    print(\"Metrics: steps =\", engine.metrics.steps, \"NVR =\", engine.metrics.nvr)\n",
    "\n",
    "\n",
    "if __name__ == \"__main__\":\n",
    "    demo_tiny_home_run()\n",
]
FILES["tests/test_basic.py"] = [
    "from erisml.core.engine import ErisEngine\n",
    "from erisml.core.norms import NormViolation\n",
    "from erisml.core.types import ActionInstance\n",
    "from erisml.examples.tiny_home import build_tiny_home_model, demo_tiny_home_run\n",
    "\n",
    "\n",
    "def test_tiny_home_norm_violation():\n",
    "    model = build_tiny_home_model()\n",
    "    engine = ErisEngine(model)\n",
    "\n",
    "    state = {\n",
    "        \"location_human\": \"r1\",\n",
    "        \"location_robot\": \"r1\",\n",
    "        \"light_on_r1\": False,\n",
    "        \"light_on_r2\": False,\n",
    "    }\n",
    "\n",
    "    a1 = ActionInstance(agent=\"Robot\", name=\"toggle_light\", params={\"room\": \"r1\"})\n",
    "    state = engine.step(state, a1)\n",
    "\n",
    "    a2 = ActionInstance(agent=\"Robot\", name=\"move_robot\", params={\"from\": \"r1\", \"to\": \"r2\"})\n",
    "\n",
    "    raised = False\n",
    "    try:\n",
    "        engine.step(state, a2)\n",
    "    except NormViolation:\n",
    "        raised = True\n",
    "\n",
    "    assert raised, \"Moving into r2 should violate norms\"\n",
    "\n",
    "\n",
    "def test_demo_runs():\n",
    "    demo_tiny_home_run()\n",
]
