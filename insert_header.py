#!/usr/bin/env python3
# ErisML is a modeling layer for governed, foundation-model-enabled agents
# Copyright (c) 2025 Andrew H. Bond
# Contact: agi.hpc@gmail.com
#
# Licensed under the AGI-HPC Responsible AI License v1.0.
# You may obtain a copy of the License at the root of this repository,
# or by contacting the author(s).
#
# You may use, modify, and distribute this file for non-commercial
# research and educational purposes, subject to the conditions in
# the License. Commercial use, high-risk deployments, and autonomous
# operation in safety-critical domains require separate written
# permission and must include appropriate safety and governance controls.
#
# Unless required by applicable law or agreed to in writing, this
# software is provided "AS IS", without warranties or conditions
# of any kind. See the License for the specific language governing
# permissions and limitations.

import argparse
import os
import sys
from typing import List

HEADER = """# ErisML is a modeling layer for governed, foundation-model-enabled agents
# Copyright (c) 2025 Andrew H. Bond
# Contact: agi.hpc@gmail.com
#
# Licensed under the AGI-HPC Responsible AI License v1.0.
# You may obtain a copy of the License at the root of this repository,
# or by contacting the author(s).
#
# You may use, modify, and distribute this file for non-commercial
# research and educational purposes, subject to the conditions in
# the License. Commercial use, high-risk deployments, and autonomous
# operation in safety-critical domains require separate written
# permission and must include appropriate safety and governance controls.
#
# Unless required by applicable law or agreed to in writing, this
# software is provided "AS IS", without warranties or conditions
# of any kind. See the License for the specific language governing
# permissions and limitations.
"""

# Directories we don't want to touch
SKIP_DIR_NAMES = {
    ".git",
    "__pycache__",
    ".venv",
    "venv",
    "env",
    ".env",
    ".mypy_cache",
    ".idea",
    "Lib",           # Windows Python install stuff
    "lib",           # *nix-style
    "site-packages",
    "dist-packages",
    "proto_gen",     # our generated code lives here
}


def should_skip_dir(path: str) -> bool:
    basename = os.path.basename(path)
    if basename in SKIP_DIR_NAMES:
        return True

    parts = path.split(os.sep)
    for p in parts:
        if p in ("site-packages", "dist-packages", "proto_gen"):
            return True

    return False


def find_python_files(root: str) -> List[str]:
    py_files: List[str] = []
    for dirpath, dirnames, filenames in os.walk(root):
        dirnames[:] = [
            d for d in dirnames
            if not should_skip_dir(os.path.join(dirpath, d))
        ]
        for filename in filenames:
            if filename.endswith(".py"):
                path = os.path.join(dirpath, filename)
                py_files.append(path)
    return py_files


def is_generated_file(path: str) -> bool:
    """
    Heuristic: skip protobuf/grpc generated files.

    We treat a file as generated if:
      - it's under a proto_gen directory, OR
      - its first few lines contain common protoc/grpc markers.
    """
    parts = path.split(os.sep)
    if "proto_gen" in parts:
        return True

    try:
        with open(path, "r", encoding="utf-8") as f:
            head = "".join([next(f) for _ in range(10)])
    except (StopIteration, FileNotFoundError, UnicodeDecodeError):
        return False

    markers = [
        "Generated protocol buffer code",
        "Generated by the gRPC Python protocol compiler plugin. DO NOT EDIT!",
        "# source: ",
    ]
    return any(m in head for m in markers)


def rewrite_header(content: str) -> str:
    """
    Keep shebang if present, remove the consecutive block of
    comment/blank lines that follow it, then insert HEADER.
    """
    lines = content.splitlines(keepends=True)

    if not lines:
        return HEADER.rstrip() + "\n"

    idx = 0
    new_lines = []

    # Preserve shebang (e.g. #!/usr/bin/env python3)
    if lines[0].startswith("#!"):
        new_lines.append(lines[0])
        idx = 1

    # From here, skip initial comment/blank lines
    while idx < len(lines):
        stripped = lines[idx].lstrip()
        if (
            stripped.startswith("#")
            or stripped == ""
            or stripped == "\n"
            or stripped == "\r\n"
        ):
            idx += 1
        else:
            break

    header_text = HEADER.rstrip() + "\n\n"
    new_lines.append(header_text)
    new_lines.extend(lines[idx:])

    return "".join(new_lines)


def process_file(path: str, dry_run: bool = False) -> bool:
    if is_generated_file(path):
        return False

    with open(path, "r", encoding="utf-8") as f:
        original = f.read()

    new_content = rewrite_header(original)

    if new_content == original:
        return False

    if not dry_run:
        with open(path, "w", encoding="utf-8") as f:
            f.write(new_content)

    return True


def main() -> None:
    parser = argparse.ArgumentParser(
        description="Replace or insert AGI-HPC license header in all non-generated Python files."
    )
    parser.add_argument(
        "root",
        nargs="?",
        default=".",
        help="Root directory of the repo (default: current directory).",
    )
    parser.add_argument(
        "--dry-run",
        action="store_true",
        help="Show which files would be modified, but do not write changes.",
    )

    args = parser.parse_args()
    root = os.path.abspath(args.root)

    if not os.path.isdir(root):
        print(f"Error: {root} is not a directory", file=sys.stderr)
        sys.exit(1)

    py_files = find_python_files(root)
    modified_count = 0

    for path in py_files:
        changed = process_file(path, dry_run=args.dry_run)
        if changed:
            modified_count += 1
            action = "Would update" if args.dry_run else "Updated"
            print(f"{action}: {os.path.relpath(path, root)}")

    if args.dry_run:
        print(f"\nDry run complete. {modified_count} file(s) would be updated.")
    else:
        print(f"\nDone. Updated {modified_count} file(s).")


if __name__ == "__main__":
    main()
